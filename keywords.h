static const char g_LispKeyWords[] = \
"*break-on-signals* "
"*compile-file-pathname* "
"*compile-file-truename* "
"*compile-print* "
"*compile-verbose* "
"*debug-io* "
"*debugger-hook* "
"*default-pathname-defaults* "
"*error-output* "
"*features* "
"*gensym-counter* "
"*load-pathname* "
"*load-print* "
"*load-truename* "
"*load-verbose* "
"*macroexpand-hook* "
"*modules* "
"*package* "
"*print-array* "
"*print-base* "
"*print-case* "
"*print-circle* "
"*print-escape* "
"*print-gensym* "
"*print-length* "
"*print-level* "
"*print-lines* "
"*print-miser-width* "
"*print-pprint-dispatch* "
"*print-pretty* "
"*print-radix* "
"*print-readably* "
"*print-right-margin* "
"*query-io* "
"*random-state* "
"*read-base* "
"*read-default-float-format* "
"*read-eval* "
"*read-suppress* "
"*readtable* "
"*standard-input* "
"*standard-output* "
"*terminal-io* "
"*trace-output* "
"&allow-other-keys "
"&aux "
"&body "
"&environment "
"&key "
"&optional "
"&rest "
"&whole "
"* "
"** "
"*** "
"+ "
"++ "
"+++ "
"- "
"/ "
"// "
"/// "
"/= "
"1+ "
"1- "
"< "
"<= "
"= "
"> "
">= "
"abort "
"abs "
"acons "
"acos "
"acosh "
"add-method "
"adjoin "
"adjust-array "
"adjustable-array-p "
"allocate-instance "
"alpha-char-p "
"alphanumericp "
"and "
"append "
"apply "
"apropos "
"apropos-list "
"aref "
"arithmetic-error "
"arithmetic-error-operands "
"arithmetic-error-operation "
"array "
"array-dimension "
"array-dimension-limit "
"array-dimensions "
"array-displacement "
"array-element-type "
"array-has-fill-pointer-p "
"array-in-bounds-p "
"array-rank "
"array-rank-limit "
"array-row-major-index "
"array-total-size "
"array-total-size-limit "
"arrayp "
"ash "
"asin "
"asinh "
"assert "
"assoc "
"assoc-if "
"assoc-if-not "
"atan "
"atanh "
"atom "
"base-char "
"base-string "
"bignum "
"bit "
"bit-and "
"bit-andc1 "
"bit-andc2 "
"bit-eqv "
"bit-ior "
"bit-nand "
"bit-nor "
"bit-not "
"bit-orc1 "
"bit-orc2 "
"bit-vector "
"bit-vector-p "
"bit-xor "
"block "
"boole "
"boole-1 "
"boole-2 "
"boole-and "
"boole-andc1 "
"boole-andc2 "
"boole-c1 "
"boole-c2 "
"boole-clr "
"boole-eqv "
"boole-ior "
"boole-nand "
"boole-nor "
"boole-orc1 "
"boole-orc2 "
"boole-set "
"boole-xor "
"boolean "
"both-case-p "
"boundp "
"break "
"broadcast-stream "
"broadcast-stream-streams "
"built-in-class "
"butlast "
"byte "
"byte-position "
"byte-size "
"caaaar "
"caaadr "
"caaar "
"caadar "
"caaddr "
"caadr "
"caar "
"cadaar "
"cadadr "
"cadar "
"caddar "
"cadddr "
"caddr "
"cadr "
"call-arguments-limit "
"call-method "
"call-next-method "
"car "
"case "
"catch "
"ccase "
"cdaaar "
"cdaadr "
"cdaar "
"cdadar "
"cdaddr "
"cdadr "
"cdar "
"cddaar "
"cddadr "
"cddar "
"cdddar "
"cddddr "
"cdddr "
"cddr "
"cdr "
"ceiling "
"cell-error "
"cell-error-name "
"cerror "
"change-class "
"char "
"char-code "
"char-code-limit "
"char-downcase "
"char-equal "
"char-greaterp "
"char-int "
"char-lessp "
"char-name "
"char-not-equal "
"char-not-greaterp "
"char-not-lessp "
"char-upcase "
"char/= "
"char< "
"char<= "
"char= "
"char> "
"char>= "
"character "
"characterp "
"check-type "
"cis "
"class "
"class-name "
"class-of "
"clear-input "
"clear-output "
"close "
"clrhash "
"code-char "
"coerce "
"compilation-speed "
"compile "
"compile-file "
"compile-file-pathname "
"compiled-function "
"compiled-function-p "
"compiler-macro "
"compiler-macro-function "
"complement "
"complex "
"complexp "
"compute-applicable-methods "
"compute-restarts "
"concatenate "
"concatenated-stream "
"concatenated-stream-streams "
"cond "
"condition "
"conjugate "
"cons "
"consp "
"constantly "
"constantp "
"continue "
"control-error "
"copy-alist "
"copy-list "
"copy-pprint-dispatch "
"copy-readtable "
"copy-seq "
"copy-structure "
"copy-symbol "
"copy-tree "
"cos "
"cosh "
"count "
"count-if "
"count-if-not "
"ctypecase "
"debug "
"decf "
"declaim "
"declaration "
"declare "
"decode-float "
"decode-universal-time "
"defclass "
"defconstant "
"defgeneric "
"define-compiler-macro "
"define-condition "
"define-method-combination "
"define-modify-macro "
"define-setf-expander "
"define-symbol-macro "
"defmacro "
"defmethod "
"defpackage "
"defparameter "
"defsetf "
"defstruct "
"deftype "
"defun "
"defvar "
"delete "
"delete-duplicates "
"delete-file "
"delete-if "
"delete-if-not "
"delete-package "
"denominator "
"deposit-field "
"describe "
"describe-object "
"destructuring-bind "
"digit-char "
"digit-char-p "
"directory "
"directory-namestring "
"disassemble "
"division-by-zero "
"do "
"do* "
"do-all-symbols "
"do-external-symbols "
"do-symbols "
"documentation "
"dolist "
"dotimes "
"double-float "
"double-float-epsilon "
"double-float-negative-epsilon "
"dpb "
"dribble "
"dynamic-extent "
"ecase "
"echo-stream "
"echo-stream-input-stream "
"echo-stream-output-stream "
"ed "
"eighth "
"elt "
"encode-universal-time "
"end-of-file "
"endp "
"enough-namestring "
"ensure-directories-exist "
"ensure-generic-function "
"eq "
"eql "
"equal "
"equalp "
"error "
"etypecase "
"eval "
"eval-when "
"evenp "
"every "
"exp "
"export "
"expt "
"extended-char "
"fboundp "
"fceiling "
"fdefinition "
"ffloor "
"fifth "
"file-author "
"file-error "
"file-error-pathname "
"file-length "
"file-namestring "
"file-position "
"file-stream "
"file-string-length "
"file-write-date "
"fill "
"fill-pointer "
"find "
"find-all-symbols "
"find-class "
"find-if "
"find-if-not "
"find-method "
"find-package "
"find-restart "
"find-symbol "
"finish-output "
"first "
"fixnum "
"flet "
"float "
"float-digits "
"float-precision "
"float-radix "
"float-sign "
"floating-point-inexact "
"floating-point-invalid-operation "
"floating-point-overflow "
"floating-point-underflow "
"floatp "
"floor "
"fmakunbound "
"force-output "
"format "
"formatter "
"fourth "
"fresh-line "
"fround "
"ftruncate "
"ftype "
"funcall "
"function "
"function-keywords "
"function-lambda-expression "
"functionp "
"gcd "
"generic-function "
"gensym "
"gentemp "
"get "
"get-decoded-time "
"get-dispatch-macro-character "
"get-internal-real-time "
"get-internal-run-time "
"get-macro-character "
"get-output-stream-string "
"get-properties "
"get-setf-expansion "
"get-universal-time "
"getf "
"gethash "
"go "
"graphic-char-p "
"handler-bind "
"handler-case "
"hash-table "
"hash-table-count "
"hash-table-p "
"hash-table-rehash-size "
"hash-table-rehash-threshold "
"hash-table-size "
"hash-table-test "
"host-namestring "
"identity "
"if "
"ignorable "
"ignore "
"ignore-errors "
"imagpart "
"import "
"in-package "
"incf "
"initialize-instance "
"inline "
"input-stream-p "
"inspect "
"integer "
"integer-decode-float "
"integer-length "
"integerp "
"interactive-stream-p "
"intern "
"internal-time-units-per-second "
"intersection "
"invalid-method-error "
"invoke-debugger "
"invoke-restart "
"invoke-restart-interactively "
"isqrt "
"keyword "
"keywordp "
"labels "
"lambda "
"lambda-list-keywords "
"lambda-parameters-limit "
"last "
"lcm "
"ldb "
"ldb-test "
"ldiff "
"least-negative-double-float "
"least-negative-long-float "
"least-negative-normalized-double-float "
"least-negative-normalized-long-float "
"least-negative-normalized-short-float "
"least-negative-normalized-single-float "
"least-negative-short-float "
"least-negative-single-float "
"least-positive-double-float "
"least-positive-long-float "
"least-positive-normalized-double-float "
"least-positive-normalized-long-float "
"least-positive-normalized-short-float "
"least-positive-normalized-single-float "
"least-positive-short-float "
"least-positive-single-float "
"length "
"let "
"let* "
"lisp-implementation-type "
"lisp-implementation-version "
"list "
"list* "
"list-all-packages "
"list-length "
"listen "
"listp "
"load "
"load-logical-pathname-translations "
"load-time-value "
"locally "
"log "
"logand "
"logandc1 "
"logandc2 "
"logbitp "
"logcount "
"logeqv "
"logical-pathname "
"logical-pathname-translations "
"logior "
"lognand "
"lognor "
"lognot "
"logorc1 "
"logorc2 "
"logtest "
"logxor "
"long-float "
"long-float-epsilon "
"long-float-negative-epsilon "
"long-site-name "
"loop "
"loop-finish "
"lower-case-p "
"machine-instance "
"machine-type "
"machine-version "
"macro-function "
"macroexpand "
"macroexpand-1 "
"macrolet "
"make-array "
"make-broadcast-stream "
"make-concatenated-stream "
"make-condition "
"make-dispatch-macro-character "
"make-echo-stream "
"make-hash-table "
"make-instance "
"make-instances-obsolete "
"make-list "
"make-load-form "
"make-load-form-saving-slots "
"make-method "
"make-package "
"make-pathname "
"make-random-state "
"make-sequence "
"make-string "
"make-string-input-stream "
"make-string-output-stream "
"make-symbol "
"make-synonym-stream "
"make-two-way-stream "
"makunbound "
"map "
"map-into "
"mapc "
"mapcan "
"mapcar "
"mapcon "
"maphash "
"mapl "
"maplist "
"mask-field "
"max "
"member "
"member-if "
"member-if-not "
"merge "
"merge-pathnames "
"method "
"method-combination "
"method-combination-error "
"method-qualifiers "
"min "
"minusp "
"mismatch "
"mod "
"most-negative-double-float "
"most-negative-fixnum "
"most-negative-long-float "
"most-negative-short-float "
"most-negative-single-float "
"most-positive-double-float "
"most-positive-fixnum "
"most-positive-long-float "
"most-positive-short-float "
"most-positive-single-float "
"muffle-warning "
"multiple-value-bind "
"multiple-value-call "
"multiple-value-list "
"multiple-value-prog1 "
"multiple-value-setq "
"multiple-values-limit "
"name-char "
"namestring "
"nbutlast "
"nconc "
"next-method-p "
"nil "
"nintersection "
"ninth "
"no-applicable-method "
"no-next-method "
"not "
"notany "
"notevery "
"notinline "
"nreconc "
"nreverse "
"nset-difference "
"nset-exclusive-or "
"nstring-capitalize "
"nstring-downcase "
"nstring-upcase "
"nsublis "
"nsubst "
"nsubst-if "
"nsubst-if-not "
"nsubstitute "
"nsubstitute-if "
"nsubstitute-if-not "
"nth "
"nth-value "
"nthcdr "
"null "
"number "
"numberp "
"numerator "
"nunion "
"oddp "
"open "
"open-stream-p "
"optimize "
"or "
"otherwise "
"output-stream-p "
"package "
"package-error "
"package-error-package "
"package-name "
"package-nicknames "
"package-shadowing-symbols "
"package-use-list "
"package-used-by-list "
"packagep "
"pairlis "
"parse-error "
"parse-integer "
"parse-namestring "
"pathname "
"pathname-device "
"pathname-directory "
"pathname-host "
"pathname-match-p "
"pathname-name "
"pathname-type "
"pathname-version "
"pathnamep "
"peek-char "
"phase "
"pi "
"plusp "
"pop "
"position "
"position-if "
"position-if-not "
"pprint "
"pprint-dispatch "
"pprint-exit-if-list-exhausted "
"pprint-fill "
"pprint-indent "
"pprint-linear "
"pprint-logical-block "
"pprint-newline "
"pprint-pop "
"pprint-tab "
"pprint-tabular "
"prin1 "
"prin1-to-string "
"princ "
"princ-to-string "
"print "
"print-not-readable "
"print-not-readable-object "
"print-object "
"print-unreadable-object "
"probe-file "
"proclaim "
"prog "
"prog* "
"prog1 "
"prog2 "
"progn "
"program-error "
"progv "
"provide "
"psetf "
"psetq "
"push "
"pushnew "
"quote "
"random "
"random-state "
"random-state-p "
"rassoc "
"rassoc-if "
"rassoc-if-not "
"ratio "
"rational "
"rationalize "
"rationalp "
"read "
"read-byte "
"read-char "
"read-char-no-hang "
"read-delimited-list "
"read-from-string "
"read-line "
"read-preserving-whitespace "
"read-sequence "
"reader-error "
"readtable "
"readtable-case "
"readtablep "
"real "
"realp "
"realpart "
"reduce "
"reinitialize-instance "
"rem "
"remf "
"remhash "
"remove "
"remove-duplicates "
"remove-if "
"remove-if-not "
"remove-method "
"remprop "
"rename-file "
"rename-package "
"replace "
"require "
"rest "
"restart "
"restart-bind "
"restart-case "
"restart-name "
"return "
"return-from "
"revappend "
"reverse "
"room "
"rotatef "
"round "
"row-major-aref "
"rplaca "
"rplacd "
"safety "
"satisfies "
"sbit "
"scale-float "
"schar "
"search "
"second "
"sequence "
"serious-condition "
"set "
"set-difference "
"set-dispatch-macro-character "
"set-exclusive-or "
"set-macro-character "
"set-pprint-dispatch "
"set-syntax-from-char "
"setf "
"setq "
"seventh "
"shadow "
"shadowing-import "
"shared-initialize "
"shiftf "
"short-float "
"short-float-epsilon "
"short-float-negative-epsilon "
"short-site-name "
"signal "
"signed-byte "
"signum "
"simple-array "
"simple-base-string "
"simple-bit-vector "
"simple-bit-vector-p "
"simple-condition "
"simple-condition-format-arguments "
"simple-condition-format-control "
"simple-error "
"simple-string "
"simple-string-p "
"simple-type-error "
"simple-vector "
"simple-vector-p "
"simple-warning "
"sin "
"single-float "
"single-float-epsilon "
"single-float-negative-epsilon "
"sinh "
"sixth "
"sleep "
"slot-boundp "
"slot-exists-p "
"slot-makunbound "
"slot-missing "
"slot-unbound "
"slot-value "
"software-type "
"software-version "
"some "
"sort "
"space "
"special "
"special-operator-p "
"speed "
"sqrt "
"stable-sort "
"standard "
"standard-char "
"standard-char-p "
"standard-class "
"standard-generic-function "
"standard-method "
"standard-object "
"step "
"storage-condition "
"store-value "
"stream "
"stream-element-type "
"stream-error "
"stream-error-stream "
"stream-external-format "
"streamp "
"string "
"string-capitalize "
"string-downcase "
"string-equal "
"string-greaterp "
"string-left-trim "
"string-lessp "
"string-not-equal "
"string-not-greaterp "
"string-not-lessp "
"string-right-trim "
"string-stream "
"string-trim "
"string-upcase "
"string/= "
"string< "
"string<= "
"string= "
"string> "
"string>= "
"stringp "
"structure "
"structure-class "
"structure-object "
"style-warning "
"sublis "
"subseq "
"subsetp "
"subst "
"subst-if "
"subst-if-not "
"substitute "
"substitute-if "
"substitute-if-not "
"subtypep "
"svref "
"sxhash "
"symbol "
"symbol-function "
"symbol-macrolet "
"symbol-name "
"symbol-package "
"symbol-plist "
"symbol-value "
"symbolp "
"synonym-stream "
"synonym-stream-symbol "
"t "
"tagbody "
"tailp "
"tan "
"tanh "
"tenth "
"terpri "
"the "
"third "
"throw "
"time "
"trace "
"translate-logical-pathname "
"translate-pathname "
"tree-equal "
"truename "
"truncate "
"two-way-stream "
"two-way-stream-input-stream "
"two-way-stream-output-stream "
"type "
"type-error "
"type-error-datum "
"type-error-expected-type "
"type-of "
"typecase "
"typep "
"unbound-slot "
"unbound-slot-instance "
"unbound-variable "
"undefined-function "
"unexport "
"unintern "
"union "
"unless "
"unread-char "
"unsigned-byte "
"untrace "
"unuse-package "
"unwind-protect "
"update-instance-for-different-class "
"update-instance-for-redefined-class "
"upgraded-array-element-type "
"upgraded-complex-part-type "
"upper-case-p "
"use-package "
"use-value "
"user-homedir-pathname "
"values "
"values-list "
"variable "
"vector "
"vector-pop "
"vector-push "
"vector-push-extend "
"vectorp "
"warn "
"warning "
"when "
"wild-pathname-p "
"with-accessors "
"with-compilation-unit "
"with-condition-restarts "
"with-hash-table-iterator "
"with-input-from-string "
"with-open-file "
"with-open-stream "
"with-output-to-string "
"with-package-iterator "
"with-simple-restart "
"with-slots "
"with-standard-io-syntax "
"write "
"write-byte "
"write-char "
"write-line "
"write-sequence "
"write-string "
"write-to-string "
"y-or-n-p "
"yes-or-no-p "
"zerop ";

static const char g_SchemeKeyWords[] = \
"+ "
"- "
"* "
"/ "
"= "
"< "
"> "
"<= "
">= "
"=> "
"+fx "
"-fx "
"*fx "
"/fx "
"+fl "
"-fl "
"*fl "
"/fl "
"=fl "
"=fx "
">fl "
">fx "
"<=fl "
"<=fx "
"abs "
"acos "
"and "
"angle "
"append "
"apply "
"asin "
"assoc "
"assoc "
"assq "
"assv "
"atan "
"begin "
"boolean? "
"caar "
"cadr "
"call-with-current-continuation "
"call/cc "
"call-with-input-file "
"call-with-output-file "
"call-with-values "
"car "
"cdr "
"caar "
"cadr "
"cdar "
"cddr "
"caaar "
"caadr "
"cadar "
"caddr "
"cdaar "
"cdadr "
"cddar "
"cdddr "
"caaaar "
"caaadr "
"caadar "
"caaddr "
"cadaar "
"cadadr "
"caddar "
"cadddr "
"cdaaar "
"cdaadr "
"cdadar "
"cdaddr "
"cddaar "
"cddadr "
"cdddar "
"cddddr "
"case "
"ceiling "
"char->integer "
"char-alphabetic? "
"char-ci<=? "
"char-ci<? "
"char-ci=? "
"char-ci>=? "
"char-ci>? "
"char-downcase "
"char-lower-case? "
"char-numeric? "
"char-ready? "
"char-upcase "
"char-upper-case? "
"char-whitespace? "
"char<=? "
"char<? "
"char=? "
"char>=? "
"char>? "
"char? "
"close-input-port "
"close-output-port "
"complex? "
"cond "
"cons "
"cos "
"current-input-port "
"current-output-port "
"define "
"define-macro "
"define-syntax "
"delay "
"denominator "
"display "
"display* "
"do "
"dynamic-wind "
"else "
"eof-object? "
"eq? "
"equal? "
"eqv? "
"eval "
"even? "
"exact->inexact "
"exact? "
"exp "
"expt "
"floor "
"for-each "
"force "
"format "
"gcd "
"if "
"imag-part "
"inexact->exact "
"inexact? "
"input-port? "
"integer->char "
"integer? "
"interaction-environment "
"lambda "
"lcm "
"length "
"let "
"let* "
"let-syntax "
"letrec "
"letrec-syntax "
"list "
"list->string "
"list->vector "
"list-ref "
"list-tail "
"list? "
"load "
"log "
"magnitude "
"make-polar "
"make-rectangular "
"make-string "
"make-vector "
"main "
"map "
"match-case "
"max "
"member "
"memq "
"memv "
"min "
"modulo "
"module "
"negative? "
"newline "
"not "
"null-environment "
"null? "
"number->string "
"number? "
"numerator "
"odd? "
"open-input-file "
"open-output-file "
"open-input-string "
"open-output-string "
"or "
"output-port? "
"open-output-procedure "
"pair? "
"peek-char "
"input-port? "
"output-port? "
"positive? "
"print "
"procedure? "
"quasiquote "
"quote "
"quotient "
"rational? "
"rationalize "
"read "
"read-char "
"real-part "
"real? "
"remainder "
"reverse "
"round "
"scheme-report-environment "
"set! "
"set-car! "
"set-cdr! "
"sin "
"sqrt "
"string "
"string->list "
"string->number "
"string->symbol "
"string-append "
"string-ci<=? "
"string-ci<? "
"string-ci=? "
"string-ci>=? "
"string-ci>? "
"string-copy "
"string-fill! "
"string-length "
"string-ref "
"string-set! "
"string<=? "
"string<? "
"string=? "
"string>=? "
"string>? "
"string? "
"substring "
"symbol->string "
"symbol? "
"syntax-rules "
"transcript-off "
"transcript-on "
"truncate "
"unquote "
"unquote-splicing "
"values "
"vector "
"vector->list "
"vector-fill! "
"vector-length "
"vector-ref "
"vector-set! "
"vector? "
"with-handler "
"with-input-from-file "
"with-output-to-file "
"with-input-from-port "
"with-output-to-port "
"with-input-from-string "
"with-output-to-string "
"with-input-from-procedure "
"with-input-from-procedure "
"write "
"write-char "
"zero? ";

static const char g_NewLispKeyWords[] = \
"Tree "
"extend "
"module "
"reader-event "
"self "
"m "
"! "
"!= "
"$ "
"$0 "
"$1 "
"$10 "
"$11 "
"$12 "
"$13 "
"$14 "
"$15 "
"$2 "
"$3 "
"$4 "
"$5 "
"$6 "
"$7 "
"$8 "
"$9 "
"$args "
"$idx "
"$it "
"$main-args "
"% "
"& "
"@ "
"* "
"+ "
"++ "
"- "
"/ "
": "
"< "
"<< "
"<= "
"= "
"> "
">= "
">> "
"? "
"NaN? "
"| "
"abort "
"abs "
"acos "
"acosh "
"add "
"address "
"amb "
"and "
"append "
"append-file "
"apply "
"args "
"array "
"array-list "
"array? "
"asin "
"asinh "
"assoc "
"atan "
"atan2 "
"atanh "
"atom? "
"base64-dec "
"base64-enc "
"bayes-query "
"bayes-train "
"begin "
"beta "
"betai "
"bind "
"binomial "
"bits "
"callback "
"case "
"catch "
"ceil "
"change-dir "
"char "
"chop "
"Class "
"clean "
"close "
"command-event "
"cond "
"cons "
"constant "
"context "
"context? "
"copy "
"copy-file "
"cos "
"cosh "
"count "
"cpymem "
"crc32 "
"crit-chi2 "
"crit-z "
"current-line "
"curry "
"date "
"date-value "
"debug "
"dec "
"def-new "
"default "
"define "
"define-macro "
"delete "
"delete-file "
"delete-url "
"destroy "
"det "
"device "
"difference "
"directory "
"directory? "
"div "
"do-until "
"do-while "
"doargs "
"dolist "
"dostring "
"dotimes "
"dotree "
"dump "
"dump-symbol "
"dup "
"empty? "
"encrypt "
"ends-with "
"env "
"erf "
"error-event "
"error-number "
"error-text "
"estack "
"eval "
"eval-string "
"exec "
"exists "
"exit "
"exp "
"expand "
"explode "
"factor "
"fft "
"file-info "
"file? "
"filter "
"find "
"find-all "
"first "
"flat "
"float "
"float? "
"floor "
"flt "
"fn "
"for "
"for-all "
"fork "
"format "
"fv "
"gammai "
"gammaln "
"gcd "
"get-char "
"get-float "
"get-int "
"get-long "
"get-string "
"get-url "
"global "
"global? "
"if "
"if-not "
"ifft "
"import "
"inc "
"index "
"inf? "
"int "
"integer "
"integer? "
"intersect "
"invert "
"irr "
"join "
"lambda "
"lambda? "
"last "
"last-error "
"legal? "
"length "
"let "
"letex "
"letn "
"list "
"list? "
"load "
"local "
"log "
"lookup "
"lower-case "
"macro? "
"MAIN "
"main-args "
"make-dir "
"map "
"mat "
"match "
"max "
"member "
"min "
"mod "
"mul "
"multiply "
"name "
"net-accept "
"net-close "
"net-connect "
"net-error "
"net-eval "
"net-interface "
"net-listen "
"net-local "
"net-lookup "
"net-peek "
"net-peer "
"net-ping "
"net-receive "
"net-receive-from "
"net-receive-udp "
"net-select "
"net-send "
"net-send-to "
"net-send-udp "
"net-service "
"net-sessions "
"new "
"nil "
"nil? "
"normal "
"not "
"now "
"nper "
"npv "
"nth "
"null? "
"number? "
"open "
"or "
"ostype "
"pack "
"parse "
"parse-date "
"peek "
"pipe "
"pmt "
"pop "
"pop-assoc "
"post-url "
"pow "
"pretty-print "
"primitive? "
"print "
"println "
"prob-chi2 "
"prob-z "
"process "
"prompt-event "
"protected? "
"push "
"put-url "
"pv "
"quote "
"quote? "
"rand "
"random "
"randomize "
"read-buffer "
"read-char "
"read-expr "
"read-file "
"read-key "
"read-line "
"read-utf8 "
"real-path "
"receive "
"ref "
"ref-all "
"regex "
"regex-comp "
"remove-dir "
"rename-file "
"replace "
"reset "
"rest "
"reverse "
"rotate "
"round "
"save "
"search "
"seed "
"seek "
"select "
"semaphore "
"send "
"sequence "
"series "
"set "
"set-locale "
"set-ref "
"set-ref-all "
"setf "
"setq "
"sgn "
"share "
"signal "
"silent "
"sin "
"sinh "
"sleep "
"slice "
"sort "
"source "
"spawn "
"sqrt "
"starts-with "
"string "
"string? "
"sub "
"swap "
"sym "
"symbol? "
"symbols "
"sync "
"sys-error "
"sys-info "
"tan "
"tanh "
"throw "
"throw-error "
"time "
"time-of-day "
"timer "
"title-case "
"trace "
"trace-highlight "
"transpose "
"trim "
"true "
"true? "
"unicode "
"unify "
"unique "
"unless "
"unpack "
"until "
"upper-case "
"utf8 "
"utf8len "
"uuid "
"wait-pid "
"when "
"while "
"write-buffer "
"write-char "
"write-file "
"write-line "
"xfer-event "
"xml-error "
"xml-parse "
"xml-type-tags "
"zero? "
"~ ";

static const char g_ISLispKeyWords[] = \
"&rest "
":abstractp "
":accessor "
":after "
":around "
":before "
":boundp "
":generic-function-class "
":initarg "
":initform "
":metaclass "
":method "
":method-combination "
":reader "
":rest "
":writer "
"and "
"assure "
"block "
"case "
"case-using "
"catch "
"class "
"cond "
"convert "
"defclass "
"defconstant "
"defdynamic "
"defgeneric "
"defglobal "
"defmacro "
"defmethod "
"defun "
"dynamic "
"dynamic-let "
"flet "
"for "
"function "
"go "
"if "
"ignore-errors "
"labels "
"lambda "
"let "
"or "
"progn "
"quote "
"return-from "
"setf "
"setq "
"tagbody "
"the "
"throw "
"unwind-protect "
"while "
"with-error-output "
"with-handler "
"with-open-input-file "
"with-open-io-file "
"with-open-output-file "
"with-standard-input "
"with-standard-output ";

static const char g_PicoLispKeyWords[] = \
"! "
"$ "
"$dat "
"$tim "
"% "
"& "
"* "
"** "
"*/ "
"*Adr "
"*Allow "
"*Bye "
"*Class "
"*DB "
"*Dbg "
"*Dbs "
"*Err "
"*Fork "
"*Hup "
"*Led "
"*Msg "
"*OS "
"*PPid "
"*Pid "
"*Run "
"*Scl "
"*Sig1 "
"*Sig2 "
"*Solo "
"*Tsm "
"*Uni "
"*Zap "
"+ "
"+Alt "
"+Any "
"+Aux "
"+Bag "
"+Blob "
"+Bool "
"+Date "
"+Dep "
"+Fold "
"+Hook "
"+Idx "
"+Joint "
"+Key "
"+Link "
"+List "
"+Mis "
"+Need "
"+Number "
"+Ref "
"+Ref2 "
"+Sn "
"+String "
"+Symbol "
"+Time "
"+index "
"+relation "
"- "
"-> "
"/ "
": "
":: "
"; "
"< "
"<= "
"<> "
"= "
"=0 "
"=: "
"== "
"==== "
"=T "
"> "
">= "
">> "
"? "
"@ "
"@@ "
"@@@ "
"NIL "
"T "
"This "
//"^ "
"abort "
"abs "
"accept "
"accu "
"alarm "
"align "
"all "
"allow "
"allowed "
"and "
"any "
"append "
"append/3 "
"apply "
"arg "
"args "
"argv "
"as "
"asoq "
"asserta "
"asserta/1 "
"assertz "
"assertz/1 "
"assoc "
"at "
"atom "
"aux "
"balance "
"be "
"beep "
"bench "
"bind "
"bit? "
"blob "
"blob! "
"bool "
"bool/3 "
"box "
"box? "
"by "
"bye "
"caaar "
"caadr "
"caar "
"cache "
"cadar "
"cadddr "
"caddr "
"cadr "
"call "
"call/1 "
"can "
"car "
"case "
"catch "
"cd "
"cdaar "
"cdadr "
"cdar "
"cddar "
"cddddr "
"cdddr "
"cddr "
"cdr "
"center "
"chain "
"char "
"chdir "
"chkTree "
"chop "
"circ "
"class "
"clause/2 "
"clip "
"close "
"cmd "
"cnt "
"collect "
"commit "
"con "
"conc "
"cond "
"connect "
"cons "
"copy "
"count "
"ctl "
"ctty "
"curry "
"cut "
"d "
"daemon "
"dat$ "
"datStr "
"datSym "
"date "
"day "
"db "
"db/3 "
"db/4 "
"db/5 "
"db: "
"dbSync "
"dbck "
"dbs "
"dbs+ "
"de "
"debug "
"dec "
"def "
"default "
"del "
"delete "
"delete/3 "
"delq "
"dep "
"depth "
"diff "
"different/2 "
"dir "
"dirname "
"dm "
"do "
"doc "
"e "
"echo "
"edit "
"env "
"eof "
"eol "
"equal/2 "
"errno "
"eval "
"expDat "
"expTel "
"expr "
"ext? "
"extend "
"extern "
"extra "
"extract "
"fail "
"fail/0 "
"fetch "
"fifo "
"file "
"fill "
"filter "
"fin "
"finally "
"find "
"fish "
"flg? "
"flip "
"flush "
"fmt64 "
"fold "
"fold/3 "
"for "
"fork "
"forked "
"format "
"free "
"from "
"full "
"fun? "
"gc "
"ge0 "
"genKey "
"get "
"getd "
"getl "
"glue "
"goal "
"group "
"gt0 "
"hd "
"head "
"head/3 "
"heap "
"hear "
"here "
"hex "
"host "
"id "
"idx "
"if "
"if2 "
"ifn "
"in "
"inc "
"inc! "
"index "
"info "
"init "
"insert "
"intern "
"ipid "
"isa "
"isa/2 "
"iter "
"job "
"journal "
"key "
"kill "
"last "
"later "
"ld "
"leaf "
"length "
"let "
"let? "
"lieu "
"line "
"lines "
"link "
"lint "
"lintAll "
"list "
"listen "
"lit "
"load "
"loc "
"locale "
"lock "
"loop "
"low? "
"lowc "
"lst/3 "
"lst? "
"lt0 "
"lup "
"macro "
"made "
"mail "
"make "
"map "
"map/3 "
"mapc "
"mapcan "
"mapcar "
"mapcon "
"maplist "
"maps "
"mark "
"match "
"max "
"maxKey "
"maxi "
"member "
"member/2 "
"memq "
"meta "
"meth "
"method "
"min "
"minKey "
"mini "
"mix "
"mmeq "
"money "
"more "
"msg "
"n0 "
"n== "
"nT "
"name "
"nand "
"native "
"need "
"new "
"new! "
"next "
"nil "
"nil/1 "
"nond "
"nor "
"not "
"not/1 "
"nth "
"num? "
"obj "
"object "
"oct "
"off "
"offset "
"on "
"onOff "
"once "
"one "
"open "
"opid "
"opt "
"or "
"or/2 "
"out "
"pack "
"pad "
"pair "
"part/3 "
"pass "
"pat? "
"patch "
"path "
"peek "
"permute/2 "
"pick "
"pid "
"pilog "
"pipe "
"place "
"poll "
"pool "
"pop "
"port "
"pp "
"pr "
"prEval "
"pre? "
"pretty "
"prin "
"prinl "
"print "
"println "
"printsp "
"proc "
"prog "
"prog1 "
"prog2 "
"prop "
"protect "
"prove "
"prune "
"push "
"push1 "
"put "
"put! "
"putl "
"pwd "
"qsym "
"query "
"queue "
"quit "
"quote "
"rand "
"range "
"range/3 "
"rank "
"raw "
"rc "
"rd "
"read "
"recur "
"recurse "
"redef "
"rel "
"remote/2 "
"remove "
"repeat "
"repeat/0 "
"replace "
"request "
"rest "
"retract "
"retract/1 "
"reverse "
"rewind "
"rollback "
"root "
"rot "
"rpc "
"rules "
"run "
"same/3 "
"scan "
"scl "
"script "
"sect "
"seed "
"seek "
"select "
"select/3 "
"send "
"seq "
"set "
"set! "
"setq "
"show "
"show/1 "
"size "
"skip "
"solve "
"sort "
"sp? "
"space "
"split "
"sqrt "
"stamp "
"state "
"stem "
"step "
"store "
"str "
"str? "
"strDat "
"strip "
"sub? "
"subr "
"sum "
"super "
"sym "
"sym? "
"sync "
"sys "
"t "
"tab "
"tail "
"task "
"telStr "
"tell "
"test "
"text "
"throw "
"tick "
"till "
"tim$ "
"time "
"timeout "
"tolr/3 "
"touch "
"trace "
"traceAll "
"tree "
"trim "
"true/0 "
"try "
"type "
"u "
"udp "
"ultimo "
"unbug "
"undef "
"unify "
"uniq "
"uniq/2 "
"unless "
"until "
"untrace "
"up "
"upd "
"update "
"upp? "
"uppc "
"use "
"useKey "
"usec "
"val "
"val/3 "
"var "
"var: "
"vi "
"view "
"wait "
"week "
"what "
"when "
"while "
"who "
"wipe "
"with "
"wr "
"wrap "
"xchg "
"xor "
"x| "
"yoke "
"zap "
"zapTree "
"zero "
"| ";

static const char g_ClojureKeyWords[] = \
"* "
"*1 "
"*2 "
"*3 "
"*agent* "
"*clojure-version* "
"*command-line-args* "
"*compile-files* "
"*compile-path* "
"*e "
"*err* "
"*file* "
"*flush-on-newline* "
"*in* "
"*load-tests* "
"*ns* "
"*out* "
"*print-dup* "
"*print-length* "
"*print-level* "
"*print-meta* "
"*print-readably* "
"*read-eval* "
"*stack-trace-depth* "
"*warn-on-reflection* "
"+ "
"- "
"-> "
"->> "
".. "
"/ "
"< "
"<= "
"= "
"== "
"> "
">= "
"accessor "
"aclone "
"add-classpath "
"add-watch "
"agent "
"agent-error "
"agent-errors "
"aget "
"alength "
"alias "
"all-ns "
"alter "
"alter-meta! "
"alter-var-root "
"amap "
"ancestors "
"and "
"append-child "
"apply "
"apply-template "
"are "
"areduce "
"array-map "
"aset "
"aset-boolean "
"aset-byte "
"aset-char "
"aset-double "
"aset-float "
"aset-int "
"aset-long "
"aset-short "
"assert "
"assert-any "
"assert-predicate "
"assoc "
"assoc! "
"assoc-in "
"associative? "
"atom "
"await "
"await-for "
"bases "
"bean "
"bigdec "
"bigint "
"binding "
"bit-and "
"bit-and-not "
"bit-clear "
"bit-flip "
"bit-not "
"bit-or "
"bit-set "
"bit-shift-left "
"bit-shift-right "
"bit-test "
"bit-xor "
"boolean "
"boolean-array "
"booleans "
"bound-fn "
"bound-fn* "
"branch? "
"butlast "
"byte "
"byte-array "
"bytes "
"case "
"cast "
"char "
"char-array "
"char-escape-string "
"char-name-string "
"char? "
"chars "
"children "
"class "
"class? "
"clear-agent-errors "
"clojure-version "
"coll? "
"comment "
"commute "
"comp "
"comparator "
"compare "
"compare-and-set! "
"compile "
"complement "
"compose-fixtures "
"concat "
"cond "
"condp "
"conj "
"conj! "
"cons "
"constantly "
"construct-proxy "
"contains? "
"count "
"counted? "
"create-ns "
"create-struct "
"cycle "
"dec "
"decimal? "
"declare "
"def "
"definline "
"defmacro "
"defmethod "
"defmulti "
"defn "
"defn- "
"defonce "
"defprotocol "
"defstruct "
"deftest "
"deftest- "
"deftype "
"delay "
"delay? "
"deliver "
"deref "
"derive "
"descendants "
"difference "
"disj "
"disj! "
"dissoc "
"dissoc! "
"distinct "
"distinct? "
"do-template "
"doall "
"doc "
"dorun "
"doseq "
"dosync "
"dotimes "
"doto "
"double "
"double-array "
"doubles "
"down "
"drop "
"drop-last "
"drop-while "
"dtype "
"e "
"edit "
"empty "
"empty? "
"end? "
"ensure "
"enumeration-seq "
"error-handler "
"error-mode "
"eval "
"even? "
"every? "
"extend "
"extend-class "
"extend-protocol "
"extend-type "
"extenders "
"extends? "
"false? "
"ffirst "
"file-position "
"file-seq "
"filter "
"find "
"find-doc "
"find-ns "
"find-var "
"first "
"float "
"float-array "
"float? "
"floats "
"flush "
"fn "
"fn? "
"fnext "
"for "
"force "
"format "
"function? "
"future "
"future-call "
"future-cancel "
"future-cancelled? "
"future-done? "
"future? "
"gen-class "
"gen-interface "
"gensym "
"get "
"get-in "
"get-method "
"get-possibly-unbound-var "
"get-proxy-class "
"get-thread-bindings "
"get-validator "
"hash "
"hash-map "
"hash-set "
"identical? "
"identity "
"if-let "
"if-not "
"ifn? "
"import "
"in-ns "
"inc "
"inc-report-counter "
"index "
"init-proxy "
"insert-child "
"insert-left "
"insert-right "
"inspect "
"inspect-table "
"inspect-tree "
"instance? "
"int "
"int-array "
"integer? "
"interleave "
"intern "
"interpose "
"intersection "
"into "
"into-array "
"ints "
"io! "
"is "
"isa? "
"iterate "
"iterator-seq "
"join "
"join-fixtures "
"juxt "
"key "
"keys "
"keyword "
"keyword? "
"keywordize-keys "
"last "
"lazy-cat "
"lazy-seq "
"left "
"leftmost "
"lefts "
"let "
"letfn "
"line-seq "
"list "
"list* "
"list? "
"load "
"load-file "
"load-reader "
"load-script "
"load-string "
"loaded-libs "
"locking "
"long "
"long-array "
"longs "
"loop "
"macroexpand "
"macroexpand-1 "
"macroexpand-all "
"main "
"make-array "
"make-hierarchy "
"make-node "
"map "
"map-invert "
"map? "
"mapcat "
"max "
"max-key "
"memfn "
"memoize "
"merge "
"merge-with "
"meta "
"methods "
"min "
"min-key "
"mod "
"name "
"namespace "
"neg? "
"newline "
"next "
"nfirst "
"nil? "
"nnext "
"node "
"not "
"not-any? "
"not-empty "
"not-every? "
"not= "
"ns "
"ns-aliases "
"ns-imports "
"ns-interns "
"ns-map "
"ns-name "
"ns-publics "
"ns-refers "
"ns-resolve "
"ns-unalias "
"ns-unmap "
"nth "
"nthnext "
"num "
"number? "
"object-array "
"odd? "
"or "
"parents "
"parse "
"partial "
"partition "
"path "
"pcalls "
"peek "
"persistent! "
"pmap "
"pop "
"pop! "
"pop-thread-bindings "
"pos? "
"postwalk "
"postwalk-demo "
"postwalk-replace "
"pr "
"pr-str "
"prefer-method "
"prefers "
"prev "
"prewalk "
"prewalk-demo "
"prewalk-replace "
"print "
"print-cause-trace "
"print-namespace-doc "
"print-stack-trace "
"print-str "
"print-throwable "
"print-trace-element "
"printf "
"println "
"println-str "
"prn "
"prn-str "
"project "
"promise "
"proxy "
"proxy-mappings "
"proxy-super "
"push-thread-bindings "
"pvalues "
"quot "
"rand "
"rand-int "
"range "
"ratio? "
"rationalize "
"re-find "
"re-groups "
"re-matcher "
"re-matches "
"re-pattern "
"re-seq "
"read "
"read-line "
"read-string "
"reduce "
"ref "
"ref-history-count "
"ref-max-history "
"ref-min-history "
"ref-set "
"refer "
"refer-clojure "
"reify "
"release-pending-sends "
"rem "
"remove "
"remove-method "
"remove-ns "
"remove-watch "
"rename "
"rename-keys "
"repeat "
"repeatedly "
"repl "
"repl-caught "
"repl-exception "
"repl-prompt "
"repl-read "
"replace "
"replicate "
"report "
"require "
"reset! "
"reset-meta! "
"resolve "
"rest "
"restart-agent "
"resultset-seq "
"reverse "
"reversible? "
"right "
"rightmost "
"rights "
"root "
"root-cause "
"rseq "
"rsubseq "
"run-all-tests "
"run-tests "
"satisfies? "
"second "
"select "
"select-keys "
"send "
"send-off "
"seq "
"seq-zip "
"seq? "
"seque "
"sequence "
"sequential? "
"set "
"set-error-handler! "
"set-error-mode! "
"set-test "
"set-validator! "
"set? "
"short "
"short-array "
"shorts "
"shutdown-agents "
"skip-if-eol "
"skip-whitespace "
"slurp "
"some "
"sort "
"sort-by "
"sorted-map "
"sorted-map-by "
"sorted-set "
"sorted-set-by "
"sorted? "
"special-form-anchor "
"special-symbol? "
"split-at "
"split-with "
"str "
"stream? "
"string? "
"stringify-keys "
"struct "
"struct-map "
"subs "
"subseq "
"subvec "
"successful? "
"supers "
"swap! "
"symbol "
"symbol? "
"sync "
"syntax-symbol-anchor "
"take "
"take-last "
"take-nth "
"take-while "
"test "
"test-all-vars "
"test-ns "
"test-var "
"testing "
"testing-contexts-str "
"testing-vars-str "
"the-ns "
"time "
"to-array "
"to-array-2d "
"trampoline "
"transient "
"tree-seq "
"true? "
"try-expr "
"type "
"unchecked-add "
"unchecked-dec "
"unchecked-divide "
"unchecked-inc "
"unchecked-multiply "
"unchecked-negate "
"unchecked-remainder "
"unchecked-subtract "
"underive "
"union "
"up "
"update-in "
"update-proxy "
"use "
"use-fixtures "
"val "
"vals "
"var-get "
"var-set "
"var? "
"vary-meta "
"vec "
"vector "
"vector-of "
"vector-zip "
"vector? "
"walk "
"when "
"when-first "
"when-let "
"when-not "
"while "
"with-bindings "
"with-bindings* "
"with-in-str "
"with-local-vars "
"with-meta "
"with-open "
"with-out-str "
"with-precision "
"with-test "
"with-test-out "
"xml-seq "
"xml-zip "
"zero? "
"zipmap "
"zipper ";

static const char g_JanetKeyWords[] = \
"% "
"%= "
"* "
"*= "
"*args* "
"*current-file* "
"*debug* "
"*defdyn-prefix* "
"*doc-color* "
"*doc-width* "
"*err* "
"*err-color* "
"*executable* "
"*exit* "
"*exit-value* "
"*ffi-context* "
"*lint-error* "
"*lint-levels* "
"*lint-warn* "
"*macro-form* "
"*macro-lints* "
"*out* "
"*peg-grammar* "
"*pretty-format* "
"*profilepath* "
"*redef* "
"*syspath* "
"+ "
"++ "
"+= "
"- "
"-- "
"-= "
"-> "
"->> "
"-?> "
"-?>> "
"/ "
"/= "
"< "
"<= "
"= "
"> "
">= "
"abstract? "
"accumulate "
"accumulate2 "
"all "
"all-bindings "
"all-dynamics "
"and "
"any? "
"apply "
"array "
"array/clear "
"array/concat "
"array/ensure "
"array/fill "
"array/insert "
"array/new "
"array/new-filled "
"array/peek "
"array/pop "
"array/push "
"array/remove "
"array/slice "
"array/trim "
"array? "
"as-> "
"as-macro "
"as?-> "
"asm "
"assert "
"bad-compile "
"bad-parse "
"band "
"blshift "
"bnot "
"boolean? "
"bor "
"brshift "
"brushift "
"buffer "
"buffer/bit "
"buffer/bit-clear "
"buffer/bit-set "
"buffer/bit-toggle "
"buffer/blit "
"buffer/clear "
"buffer/fill "
"buffer/format "
"buffer/new "
"buffer/new-filled "
"buffer/popn "
"buffer/push "
"buffer/push-byte "
"buffer/push-string "
"buffer/push-word "
"buffer/slice "
"buffer/trim "
"buffer? "
"bxor "
"bytes? "
"cancel "
"case "
"cfunction? "
"chr "
"cli-main "
"cmp "
"comment "
"comp "
"compare "
"compare< "
"compare<= "
"compare= "
"compare> "
"compare>= "
"compif "
"compile "
"complement "
"comptime "
"compwhen "
"cond "
"coro "
"count "
"curenv "
"debug "
"debug/arg-stack "
"debug/break "
"debug/fbreak "
"debug/lineage "
"debug/stack "
"debug/stacktrace "
"debug/step "
"debug/unbreak "
"debug/unfbreak "
"debugger "
"debugger-env "
"debugger-on-status "
"dec "
"deep-not= "
"deep= "
"def- "
"default "
"default-peg-grammar "
"defdyn "
"defer "
"defglobal "
"defmacro "
"defmacro- "
"defn "
"defn- "
"delay "
"describe "
"dictionary? "
"disasm "
"distinct "
"doc "
"doc* "
"doc-format "
"doc-of "
"dofile "
"drop "
"drop-until "
"drop-while "
"dyn "
"each "
"eachk "
"eachp "
"edefer "
"eflush "
"empty? "
"env-lookup "
"eprin "
"eprinf "
"eprint "
"eprintf "
"error "
"errorf "
"ev/acquire-lock "
"ev/acquire-rlock "
"ev/acquire-wlock "
"ev/call "
"ev/cancel "
"ev/capacity "
"ev/chan "
"ev/chan-close "
"ev/chunk "
"ev/close "
"ev/count "
"ev/deadline "
"ev/do-thread "
"ev/full "
"ev/gather "
"ev/give "
"ev/give-supervisor "
"ev/go "
"ev/lock "
"ev/read "
"ev/release-lock "
"ev/release-rlock "
"ev/release-wlock "
"ev/rselect "
"ev/rwlock "
"ev/select "
"ev/sleep "
"ev/spawn "
"ev/spawn-thread "
"ev/take "
"ev/thread "
"ev/thread-chan "
"ev/with-deadline "
"ev/write "
"eval "
"eval-string "
"even? "
"every? "
"extreme "
"false? "
"ffi/align "
"ffi/call "
"ffi/close "
"ffi/context "
"ffi/defbind "
"ffi/lookup "
"ffi/native "
"ffi/read "
"ffi/signature "
"ffi/size "
"ffi/struct "
"ffi/trampoline "
"ffi/write "
"fiber-fn "
"fiber/can-resume? "
"fiber/current "
"fiber/getenv "
"fiber/last-value "
"fiber/maxstack "
"fiber/new "
"fiber/root "
"fiber/setenv "
"fiber/setmaxstack "
"fiber/status "
"fiber? "
"file/close "
"file/flush "
"file/open "
"file/read "
"file/seek "
"file/temp "
"file/write "
"filter "
"find "
"find-index "
"first "
"flatten "
"flatten-into "
"flush "
"flycheck "
"for "
"forever "
"forv "
"freeze "
"frequencies "
"from-pairs "
"function? "
"gccollect "
"gcinterval "
"gcsetinterval "
"generate "
"gensym "
"get "
"get-in "
"getline "
"getproto "
"group-by "
"hash "
"idempotent? "
"identity "
"if-let "
"if-not "
"if-with "
"import "
"import* "
"in "
"inc "
"index-of "
"indexed? "
"int/s64 "
"int/to-bytes "
"int/to-number "
"int/u64 "
"int? "
"interleave "
"interpose "
"invert "
"janet/build "
"janet/config-bits "
"janet/version "
"juxt "
"juxt* "
"keep "
"keys "
"keyword "
"keyword/slice "
"keyword? "
"kvs "
"label "
"last "
"length "
"let "
"load-image "
"load-image-dict "
"loop "
"macex "
"macex1 "
"maclintf "
"make-env "
"make-image "
"make-image-dict "
"map "
"mapcat "
"marshal "
"match "
"math/-inf "
"math/abs "
"math/acos "
"math/acosh "
"math/asin "
"math/asinh "
"math/atan "
"math/atan2 "
"math/atanh "
"math/cbrt "
"math/ceil "
"math/cos "
"math/cosh "
"math/e "
"math/erf "
"math/erfc "
"math/exp "
"math/exp2 "
"math/expm1 "
"math/floor "
"math/gamma "
"math/gcd "
"math/hypot "
"math/inf "
"math/int-max "
"math/int-min "
"math/int32-max "
"math/int32-min "
"math/lcm "
"math/log "
"math/log-gamma "
"math/log10 "
"math/log1p "
"math/log2 "
"math/nan "
"math/next "
"math/pi "
"math/pow "
"math/random "
"math/rng "
"math/rng-buffer "
"math/rng-int "
"math/rng-uniform "
"math/round "
"math/seedrandom "
"math/sin "
"math/sinh "
"math/sqrt "
"math/tan "
"math/tanh "
"math/trunc "
"max "
"max-of "
"mean "
"merge "
"merge-into "
"merge-module "
"min "
"min-of "
"mod "
"module/add-paths "
"module/cache "
"module/expand-path "
"module/find "
"module/loaders "
"module/loading "
"module/paths "
"module/value "
"nan? "
"nat? "
"native "
"neg? "
"net/accept "
"net/accept-loop "
"net/address "
"net/address-unpack "
"net/chunk "
"net/close "
"net/connect "
"net/flush "
"net/listen "
"net/localname "
"net/peername "
"net/read "
"net/recv-from "
"net/send-to "
"net/server "
"net/shutdown "
"net/write "
"next "
"nil? "
"not "
"not= "
"number? "
"odd? "
"one? "
"or "
"os/arch "
"os/cd "
"os/chmod "
"os/clock "
"os/cpu-count "
"os/cryptorand "
"os/cwd "
"os/date "
"os/dir "
"os/environ "
"os/execute "
"os/exit "
"os/getenv "
"os/link "
"os/lstat "
"os/mkdir "
"os/mktime "
"os/open "
"os/perm-int "
"os/perm-string "
"os/pipe "
"os/proc-close "
"os/proc-kill "
"os/proc-wait "
"os/readlink "
"os/realpath "
"os/rename "
"os/rm "
"os/rmdir "
"os/setenv "
"os/shell "
"os/sleep "
"os/spawn "
"os/stat "
"os/symlink "
"os/time "
"os/touch "
"os/umask "
"os/which "
"pairs "
"parse "
"parse-all "
"parser/byte "
"parser/clone "
"parser/consume "
"parser/eof "
"parser/error "
"parser/flush "
"parser/has-more "
"parser/insert "
"parser/new "
"parser/produce "
"parser/state "
"parser/status "
"parser/where "
"partial "
"partition "
"partition-by "
"peg/compile "
"peg/find "
"peg/find-all "
"peg/match "
"peg/replace "
"peg/replace-all "
"pos? "
"postwalk "
"pp "
"prewalk "
"prin "
"prinf "
"print "
"printf "
"product "
"prompt "
"propagate "
"protect "
"put "
"put-in "
"quit "
"range "
"reduce "
"reduce2 "
"repeat "
"repl "
"require "
"resume "
"return "
"reverse "
"reverse! "
"root-env "
"run-context "
"scan-number "
"seq "
"setdyn "
"short-fn "
"signal "
"slice "
"slurp "
"some "
"sort "
"sort-by "
"sorted "
"sorted-by "
"spit "
"stderr "
"stdin "
"stdout "
"string "
"string/ascii-lower "
"string/ascii-upper "
"string/bytes "
"string/check-set "
"string/find "
"string/find-all "
"string/format "
"string/from-bytes "
"string/has-prefix? "
"string/has-suffix? "
"string/join "
"string/repeat "
"string/replace "
"string/replace-all "
"string/reverse "
"string/slice "
"string/split "
"string/trim "
"string/triml "
"string/trimr "
"string? "
"struct "
"struct/getproto "
"struct/proto-flatten "
"struct/to-table "
"struct/with-proto "
"struct? "
"sum "
"symbol "
"symbol/slice "
"symbol? "
"table "
"table/clear "
"table/clone "
"table/getproto "
"table/new "
"table/proto-flatten "
"table/rawget "
"table/setproto "
"table/to-struct "
"table? "
"tabseq "
"take "
"take-until "
"take-while "
"toggle "
"trace "
"tracev "
"true? "
"truthy? "
"try "
"tuple "
"tuple/brackets "
"tuple/setmap "
"tuple/slice "
"tuple/sourcemap "
"tuple/type "
"tuple? "
"type "
"unless "
"unmarshal "
"untrace "
"update "
"update-in "
"use "
"values "
"var- "
"varfn "
"varglobal "
"walk "
"warn-compile "
"when "
"when-let "
"when-with "
"with "
"with-dyns "
"with-syms "
"with-vars "
"xprin "
"xprinf "
"xprint "
"xprintf "
"yield "
"zero? "
"zipcoll ";
